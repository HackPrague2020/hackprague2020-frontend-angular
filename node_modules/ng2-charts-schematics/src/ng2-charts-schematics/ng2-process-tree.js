"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const schematics_1 = require("@angular-devkit/schematics");
const ast_utils_1 = require("@schematics/angular/utility/ast-utils");
const find_module_1 = require("@schematics/angular/utility/find-module");
const read_into_source_file_1 = require("./read-into-source-file");
const ts = require("typescript");
const change_1 = require("@schematics/angular/utility/change");
const project_1 = require("@schematics/angular/utility/project");
function ng2ProcessTree(tree, _context, _options, newCode, newMarkup, newImports = []) {
    if (!_options.project) {
        throw new schematics_1.SchematicsException('Option (project) is required.');
    }
    const project = project_1.getProject(tree, _options.project);
    if (_options.path === undefined) {
        _options.path = project_1.buildDefaultPath(project);
    }
    _options.module = find_module_1.findModuleFromOptions(tree, _options);
    const codeAction = tree.actions.filter(r => r.path.endsWith('.component.ts'))[0];
    const markupActions = tree.actions.filter(r => r.path.endsWith('.component.html'));
    const codeSource = read_into_source_file_1.readIntoSourceFile(tree, codeAction.path);
    const nodes = ast_utils_1.getSourceNodes(codeSource);
    const classNodes = nodes.filter(r => ast_utils_1.findNodes(r, ts.SyntaxKind.ClassDeclaration).length);
    const classDecl = ast_utils_1.findNodes(classNodes[0], ts.SyntaxKind.ClassDeclaration)[0];
    let inlineTemplate = false;
    let template;
    const changes = newImports.map(([a, b]) => ast_utils_1.insertImport(codeSource, codeAction.path, a, b));
    const recorder = tree.beginUpdate(codeAction.path);
    if (classDecl.decorators) {
        const decorator = classDecl.decorators[0];
        const literal = ast_utils_1.findNodes(decorator.expression, ts.SyntaxKind.ObjectLiteralExpression)[0];
        template = literal.properties.filter(r => ts.isPropertyAssignment(r) &&
            ts.isIdentifier(r.name) &&
            r.name.escapedText === 'template')[0];
        if (template) {
            const newNode = ts.createStringLiteral('`' + newMarkup + '`');
            const start = template.initializer.getStart();
            const end = template.initializer.getEnd();
            recorder.remove(start, end - start);
            recorder.insertLeft(start, newNode.text);
            inlineTemplate = true;
        }
    }
    if (!inlineTemplate && markupActions.length) {
        const markupAction = markupActions[0];
        tree.overwrite(markupAction.path, newMarkup);
    }
    const start2 = classDecl.members[0].getStart();
    const end2 = classDecl.members[classDecl.members.length - 1].getEnd();
    recorder.remove(start2, end2 - start2);
    recorder.insertLeft(start2, newCode);
    for (const change of changes) {
        if (change instanceof change_1.InsertChange) {
            recorder.insertLeft(change.pos, change.toAdd);
        }
    }
    if (_options.module) {
        const moduleSource = read_into_source_file_1.readIntoSourceFile(tree, _options.module);
        const addImport = ast_utils_1.addImportToModule(moduleSource, _options.module, 'ChartsModule', 'ng2-charts');
        console.log('import', addImport);
        for (const change of addImport) {
            if (change instanceof change_1.InsertChange) {
                recorder.insertLeft(change.pos, change.toAdd);
            }
        }
    }
    tree.commitUpdate(recorder);
    return tree;
}
exports.ng2ProcessTree = ng2ProcessTree;
//# sourceMappingURL=ng2-process-tree.js.map